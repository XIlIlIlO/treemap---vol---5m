<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>SUPERHERO Heatmap — Volatility × Turnover</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root {
      /* ⇩ 여기만 만지면 크기 변경 (임베드 안정) */
      --chart-w: 1280px;
      --chart-h: 720px;
    }
    html, body {
      margin: 0; padding: 0;
      background: #0a0b0d; color: #e8e8e8;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
      width: 100vw; height: 100vh; overflow: hidden;
    }
    .wrap {
      height: 100%; display: grid; place-items: center;
    }
    .board {
      width: var(--chart-w); height: var(--chart-h);
      background: #060708; border: 1px solid #17191d; border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.45);
      display: grid; grid-template-rows: 56px 1fr;
      overflow: hidden;
    }
    .topbar {
      display: flex; align-items: center; justify-content: space-between;
      padding: 0 16px; border-bottom: 1px solid #17191d;
    }
    .title {
      font-weight: 800; letter-spacing: .2px; color: #eaeef3; font-size: 18px;
    }
    .right { display: flex; align-items: center; gap: 16px; font-size: 13px; color:#a6adbb; }
    select {
      background: #0f1217; color: #eaeef3; border: 1px solid #20242c; border-radius: 6px;
      padding: 6px 10px; outline: none; font-size: 13px;
    }
    #countdown { color:#7f8896; }
    svg { display:block; }
    .cell { cursor: pointer; }
    .cell rect {
      rx: 6; ry: 6;
      stroke: #0c0e12; stroke-width: 1; /* 얇은 경계 */
    }
    .sym {
      fill: #f7f9fb; font-weight: 800; text-anchor: middle;
      paint-order: stroke; stroke: rgba(0,0,0,.35); stroke-width: 3px; stroke-linejoin: round;
    }
    .pct {
      fill: #f1f5f9; font-weight: 700; text-anchor: middle;
      paint-order: stroke; stroke: rgba(0,0,0,.28); stroke-width: 2px; stroke-linejoin: round;
    }
    .tiny { fill:#e8ecf2; font-weight:700; text-anchor: middle; opacity:.95; }
    .tooltip {
      position: fixed; pointer-events: none; z-index: 50;
      background: rgba(12,14,18,.96); color: #fff; border: 1px solid #232831; border-radius: 8px;
      padding: 10px 12px; font-size: 13px; line-height: 1.5;
      box-shadow: 0 8px 20px rgba(0,0,0,.35);
      display:none; opacity:0;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board">
      <div class="topbar">
        <div class="title">#CRYPTO — REAL-TIME HEATMAP</div>
        <div class="right">
          <label for="endpoint">뷰</label>
          <select id="endpoint" title="데이터 소스 선택">
            <option value="/top_volatility_1m">1m 변동성</option>
            <option value="/top_volatility_5m" selected>5m 변동성</option>
            <option value="/top_volatility_15m">15m 변동성</option>
            <option value="/top_volatility_1h">1h 변동성</option>
            <option value="/top_spike_1h_recent">신규코인 급등(≤6m)</option>
            <option value="/top_dump_1h_recent">신규코인 급락(≤6m)</option>
            <option value="/top_spike_1h_all">전종목 급등(1h)</option>
            <option value="/top_dump_1h_all">전종목 급락(1h)</option>
          </select>
          <span id="time">UTC …</span>
          <span id="countdown">60s</span>
        </div>
      </div>
      <div id="stage">
        <svg id="chart" width="100%" height="100%"></svg>
      </div>
    </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script>
    /* ==============================
       ❶ 고정 크기 설정
       ============================== */
    const CHART_W = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--chart-w'));
    const CHART_H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--chart-h'));
    const svg = d3.select("#chart").attr("width", CHART_W).attr("height", CHART_H);

    /* ==============================
       ❷ 데이터 소스
       ============================== */
    const API_BASE = "https://binance-flask-app-production.up.railway.app";
    const endpointSel = document.getElementById("endpoint");
    const tooltip = document.getElementById("tooltip");

    /* ==============================
       ❸ 시간 표시 & 카운트다운
       ============================== */
    let secondsToNextUpdate = 60;
    function updateTimeLabel(){
      const now = new Date();
      const y = now.getUTCFullYear();
      const m = String(now.getUTCMonth()+1).padStart(2,'0');
      const d = String(now.getUTCDate()).padStart(2,'0');
      const h = String(now.getUTCHours()).padStart(2,'0');
      const mm = String(now.getUTCMinutes()).padStart(2,'0');
      document.getElementById("time").textContent = `${y}-${m}-${d} ${h}:${mm} UTC`;
    }
    setInterval(() => {
      secondsToNextUpdate = secondsToNextUpdate <= 1 ? 60 : secondsToNextUpdate-1;
      document.getElementById("countdown").textContent = `${secondsToNextUpdate}s`;
    }, 1000);

    /* ==============================
       ❹ 유틸
       ============================== */
    const fmtPct = v => `${(+v).toFixed(2)}%`;
    function kmb(num){
      const n = +num || 0;
      if (n >= 1e12) return (n/1e12).toFixed(2)+'T';
      if (n >= 1e9 ) return (n/1e9 ).toFixed(2)+'B';
      if (n >= 1e6 ) return (n/1e6 ).toFixed(2)+'M';
      if (n >= 1e3 ) return (n/1e3 ).toFixed(2)+'K';
      return n.toFixed(0);
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    // MSFT/AAPL 스타일의 선명한 녹/적 팔레트 (밝기 가변)
    const GREEN = [175,255,0];  // #afff00
    const RED   = [247, 63,33]; // #f73f21
    function colorMix(baseRGB, factor){
      // factor 0.25~1.00 범위 권장
      const f = Math.max(.25, Math.min(1, factor));
      const [r,g,b] = baseRGB.map(c => Math.round(c * f));
      return `rgb(${r},${g},${b})`;
    }

    /* ==============================
       ❺ 데이터 표준화
       - 변동성 계열: volatility / volume_usdt / color
       - 급등/급락 계열: spike_pct / dump_pct / volume_usdt_1h / color
       ============================== */
    function normalize(raw, path){
      const arr = Array.isArray(raw) ? raw : (Array.isArray(raw?.data) ? raw.data : []);
      const isSpike = path.includes("_spike_");
      const isDump  = path.includes("_dump_");
      return arr.map(d=>{
        const sym = d.symbol || d.futures_symbol || d.name || "NA";
        let pct = 0, volUSD = 0, col = d.color || "green";
        if ("volatility" in d) { pct = +d.volatility || 0; volUSD = +d.volume_usdt || 0; }
        else {
          pct = isSpike ? (+d.spike_pct||0) : isDump ? (+d.dump_pct||0) : 0;
          volUSD = +d.volume_usdt_1h || 0;
        }
        return { symbol:sym, pct, volUSD, col };
      }).filter(x=>x.symbol && x.volUSD >= 0 && x.pct >= 0);
    }

    async function fetchJSON(path){
      const res = await fetch(API_BASE + path, {cache:"no-store"});
      return await res.json();
    }

    /* ==============================
       ❻ 렌더 — S&P500 스타일 Heatmap
       ============================== */
    function render(data){
      svg.selectAll("*").remove();
      if (!data.length) return;

      const maxPct  = d3.max(data, d => d.pct) || 1;
      const sumTurn = d3.sum(data, d => Math.max(1e-6, d.volUSD));

      // 트리맵 레이아웃 (작은 갭, 균일 분배 느낌)
      const root = d3.hierarchy({children:data})
        .sum(d => Math.max(1e-4, d.volUSD))
        .sort((a,b)=> (b.data.pct||0) - (a.data.pct||0));

      d3.treemap()
        .size([CHART_W, CHART_H-56])  // 상단바 제외 높이
        .paddingInner(2)              // S&P500 스타일의 얇은 그리드
        .paddingOuter(6)
        .round(true)(root);

      const g = svg.append("g").attr("transform", `translate(0,56)`);

      const cell = g.selectAll("g.cell")
        .data(root.leaves(), d=>d.data.symbol)
        .enter().append("g")
        .attr("class","cell")
        .attr("transform", d=>`translate(${d.x0},${d.y0})`)
        .on("mousemove", (ev,d)=>{
          tooltip.innerHTML =
            `<b>${d.data.symbol}</b><br>
             변화: <b>${fmtPct(d.data.pct)}</b><br>
             거래대금: <b>${kmb(d.data.volUSD)}</b> USDT`;
          tooltip.style.left=(ev.clientX+12)+"px";
          tooltip.style.top =(ev.clientY+12)+"px";
          tooltip.style.display="block"; tooltip.style.opacity=1;
        })
        .on("mouseleave", ()=>{ tooltip.style.opacity=0; tooltip.style.display="none"; })
        .on("click", (ev,d)=> window.open(`https://www.binance.com/en/futures/${d.data.symbol}`,'_blank'));

      // 색상: 방향(녹/적) + 강도(변동성)
      cell.append("rect")
        .attr("width", d=>Math.max(0,d.x1-d.x0))
        .attr("height",d=>Math.max(0,d.y1-d.y0))
        .attr("fill", d=>{
          const base = d.data.col === "green" ? GREEN : RED;
          const factor = 0.35 + 0.65 * (d.data.pct / maxPct); // 0.35~1.0
          return colorMix(base, factor);
        });

      // 타일 중심 좌표
      function cx(d){ return (d.x0 + d.x1)/2; }
      function cy(d){ return (d.y0 + d.y1)/2; }
      function w (d){ return (d.x1 - d.x0); }
      function h (d){ return (d.y1 - d.y0); }

      // 큰 타일: 심볼(굵게) + % 중앙 배치
      const BIG_MIN_W = 180, BIG_MIN_H = 120;
      const MED_MIN_W = 110, MED_MIN_H = 70;

      // 심볼
      cell.append("text")
        .attr("class","sym")
        .attr("x", d=>cx(d))
        .attr("y", d=>cy(d) - 6)
        .style("font-size", d=>{
          const s = Math.min(Math.max(16, w(d)*0.18), 42);
          return s + "px";
        })
        .text(d=>{
          if (w(d) >= MED_MIN_W && h(d) >= MED_MIN_H) return d.data.symbol;
          if (w(d) >= 70 && h(d) >= 40) return d.data.symbol;
          return ""; // 너무 작으면 숨김
        });

      // 퍼센트
      cell.append("text")
        .attr("class","pct")
        .attr("x", d=>cx(d))
        .attr("y", d=>cy(d) + 22)
        .style("font-size", d=>{
          const s = Math.min(Math.max(12, w(d)*0.12), 28);
          return s + "px";
        })
        .text(d=>{
          if (w(d) >= BIG_MIN_W && h(d) >= BIG_MIN_H) return (d.data.col==="green" ? "+" : "−") + fmtPct(d.data.pct).replace("%","") + "%";
          if (w(d) >= MED_MIN_W && h(d) >= MED_MIN_H) return (d.data.col==="green" ? "+" : "−") + d.data.pct.toFixed(2) + "%";
          return "";
        });

      // 아주 작은 타일: 좌상단에 작은 심볼만
      cell.append("text")
        .attr("class","tiny")
        .attr("x", d=>d.x0 + 6)
        .attr("y", d=>d.y0 + 14)
        .style("font-size", d=> Math.max(9, Math.min(12, w(d)*0.12)) + "px")
        .text(d=>{
          if (w(d) < MED_MIN_W || h(d) < MED_MIN_H) {
            if (w(d) >= 42 && h(d) >= 24) return d.data.symbol;
          }
          return "";
        });
    }

    /* ==============================
       ❼ 주기 갱신
       ============================== */
    async function refresh(){
      updateTimeLabel();
      secondsToNextUpdate = 60;
      const path = endpointSel.value;
      let raw;
      try { raw = await fetchJSON(path); }
      catch { render([]); return; }
      const data = normalize(raw, path);
      render(data);
    }

    endpointSel.addEventListener("change", refresh);
    setInterval(refresh, 60*1000);
    refresh();
  </script>
</body>
</html>
