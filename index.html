<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>SUPERHERO Treemap — Volatility × Turnover (Auto 60s)</title>

  <!-- (필요 시 남겨둠) d3는 더 이상 사용하지 않지만 다른 부분 의존 고려해 유지 가능 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <!-- ★ 추가: Chart.js & chartjs-chart-treemap -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@2.3.0/dist/chartjs-chart-treemap.min.js"></script>

  <style>
    :root { --scale: 0.70; }

    html, body {
      margin: 0; padding: 0;
      background: #000; color: #fff; font-family: system-ui, -apple-system, Roboto, sans-serif;
      overflow: hidden; width: 100vw; height: 100vh;
    }
    body {
      transform: scale(var(--scale));
      transform-origin: top left;
      width: calc(100% / var(--scale));
      height: calc(100% / var(--scale));
      padding: calc(28px / var(--scale));
    }

    h1 { font-size: 24px; margin: 0 0 12px 0; }
    .row { display: flex; gap: 16px; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
    label, select { font-size: 14px; color: #ddd; }
    select {
      background: #111; color: #fff; border: 1px solid #333; border-radius: 6px; padding: 6px 10px;
      outline: none;
    }
    #time { font-size: 14px; color: #aaa; }
    #countdown { margin-left: 12px; color: #888; }

    /* ▼ 트리맵 고정 사이즈 */
    :root { --treemap-w: 1280px; --treemap-h: 720px; }
    #chartWrap { width: var(--treemap-w); height: var(--treemap-h); }
    /* ★ 변경: 캔버스(Chart.js) 스타일 */
    #chart-area { width: var(--treemap-w); height: var(--treemap-h); display:block; border:1px solid #222; border-radius:10px; }

    /* 글자 스타일은 Chart.js 내부라 CSS 영향 적음. tooltip은 브라우저 기본 사용 X */
    .tooltip { display:none; }
    .legend { font-size: 12px; color: #bbb; display:flex; gap:16px; align-items:center; }
    .chip { width:14px; height:14px; border-radius: 3px; display:inline-block; margin-right:6px; border:1px solid #333; }
    .chip.up { background:#afff00; }
    .chip.down { background:#f73f21; }
  </style>
</head>
<body>
  <h1>■ SUPERHERO 실시간 트리맵 (면적=거래대금, 색상=등락, 진하기=변동성) ■</h1>

  <div class="row">
    <div class="legend">
      <span><span class="chip up"></span>상승</span>
      <span><span class="chip down"></span>하락</span>
      <span>진하기 ↑ = 변동성(%) ↑</span>
      <span>면적 ↑ = 거래대금(USDT) ↑</span>
    </div>
  </div>

  <div class="row">
    <label for="endpoint">엔드포인트:</label>
    <select id="endpoint">
      <!-- 변동성 랭킹 계열 -->
      <option value="/top_volatility_1m">1분 변동성</option>
      <option value="/top_volatility_5m" selected>5분 변동성</option>
      <option value="/top_volatility_15m">15분 변동성</option>
      <option value="/top_volatility_1h">1시간 변동성</option>
      <!-- 신규코인 급등/급락 (≤6개월) -->
      <option value="/top_spike_1h_recent">신규코인 급등(1H)</option>
      <option value="/top_dump_1h_recent">신규코인 급락(1H)</option>
      <!-- 전종목 급등/급락 -->
      <option value="/top_spike_1h_all">전종목 급등(1H)</option>
      <option value="/top_dump_1h_all">전종목 급락(1H)</option>
    </select>

    <span id="time">UTC 로딩 중...</span>
    <span id="countdown">다음 갱신까지 60s</span>
  </div>

  <div id="chartWrap">
    <!-- ★ 변경: SVG → Canvas -->
    <canvas id="chart-area"></canvas>
  </div>

  <!-- 유지(사용 안 함) -->
  <div id="tooltip" class="tooltip"></div>

  <script>
    // ====== 기본 API 베이스 ======
    const API_BASE = "https://binance-flask-app-production.up.railway.app";

    // ====== 셀렉터와 UI 타이머 ======
    const endpointSel = document.getElementById("endpoint");
    let secondsToNextUpdate = 60;

    function updateTimeLabel() {
      const now = new Date();
      const y = now.getUTCFullYear();
      const m = String(now.getUTCMonth() + 1).padStart(2, '0');
      const d = String(now.getUTCDate()).padStart(2, '0');
      const h = String(now.getUTCHours()).padStart(2, '0');
      const mm = String(now.getUTCMinutes()).padStart(2, '0');
      document.getElementById("time").textContent = `${y}-${m}-${d} ${h}:${mm} UTC`;
    }
    function startCountdown() {
      setInterval(() => {
        secondsToNextUpdate--;
        if (secondsToNextUpdate <= 0) secondsToNextUpdate = 60;
        document.getElementById("countdown").textContent = `다음 갱신까지 ${secondsToNextUpdate}s`;
      }, 1000);
    }

    // ====== 유틸 ======
    const fmtPct = v => `${(+v).toFixed(2)}%`;
    function formatCompact(num) {
      const n = +num || 0;
      if (n >= 1e12) return (n / 1e12).toFixed(2) + "T";
      if (n >= 1e9)  return (n / 1e9 ).toFixed(2) + "B";
      if (n >= 1e6)  return (n / 1e6 ).toFixed(2) + "M";
      if (n >= 1e3)  return (n / 1e3 ).toFixed(2) + "K";
      return n.toFixed(0);
    }
    const colorBaseHex = c => (c === "green" ? "#2db84d" : "#c6453a"); // 약한 녹/적

    // 색 진하기를 변동성(%)에 맞춰 보정 (0~1) → 0.30~1.00
    function intensity(volPct, maxVol) {
      if (maxVol <= 0) return 0.6;
      const r = Math.max(0, Math.min(1, volPct / maxVol));
      return 0.30 + r * 0.70;
    }

    // ====== 데이터 표준화 ======
    function normalizeData(raw, endpointPath) {
      const arr = Array.isArray(raw) ? raw : (Array.isArray(raw?.data) ? raw.data : []);
      const isSpike = endpointPath.includes("_spike_");
      const isDump  = endpointPath.includes("_dump_");
      return arr.map(d => {
        let vol = 0, volUSD = 0, col = d.color;
        if ("volatility" in d) {
          vol = +d.volatility || 0;
          volUSD = +d.volume_usdt || 0;
        } else {
          if (isSpike) vol = +d.spike_pct || 0;
          if (isDump)  vol = +d.dump_pct  || 0;
          volUSD = +d.volume_usdt_1h || 0;
        }
        const sym = d.symbol || d.futures_symbol || d.name || "NA";
        return { symbol: sym, volatility: vol, volume_usdt: volUSD, color: col || "green" };
      }).filter(d => d.symbol && d.volume_usdt >= 0 && d.volatility >= 0);
    }

    // ====== 선택/정돈(너무 작은 타일 제거) ======
    const TREEMAP_MAX_ITEMS = 28;
    const MIN_AREA_RATIO    = 0.01; // 전체의 1% 미만 제거
    function selectForLayout(data, width, height) {
      const total = data.reduce((s,d)=>s + (d.volume_usdt||0), 0);
      const area  = width * height;
      const minArea = area * MIN_AREA_RATIO;

      const sorted = data.slice().sort((a,b) => (b.volume_usdt||0) - (a.volume_usdt||0));
      const picked = [];
      for (const d of sorted) {
        if (picked.length >= TREEMAP_MAX_ITEMS) break;
        const estArea = total > 0 ? (d.volume_usdt / total) * area : 0;
        if (estArea >= minArea) picked.push(d);
      }
      if (!picked.length && sorted.length) picked.push(sorted[0]);
      return picked;
    }

    // ====== Chart.js Treemap ======
    let treemapChart = null;
    function renderTreemap(data) {
      const w = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-w'));
      const h = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-h'));

      const filtered = selectForLayout(data, w, h);
      const maxVol   = Math.max(...filtered.map(d => d.volatility || 0), 0);

      // Chart.js treemap: tree 객체 준비
      const tree = filtered.map(d => {
        const sign = d.color === "green" ? "+" : "−";
        return {
          symbol: d.symbol,
          area:   d.volume_usdt,          // 면적 기준
          vol:    d.volatility,           // 색 진하기
          color:  d.color,                // green/red
          displayValue: `${d.symbol}\n${sign}${d.volatility.toFixed(2)}%`
        };
      });

      const ctx = document.getElementById("chart-area").getContext("2d");

      const backgroundColor = (c) => {
        const raw = c.raw || {};
        const base = colorBaseHex(raw.color || "green");
        // hex → rgb
        const r = parseInt(base.slice(1,3),16);
        const g = parseInt(base.slice(3,5),16);
        const b = parseInt(base.slice(5,7),16);
        const f = intensity(raw.vol || 0, maxVol); // 0.30~1.00
        return `rgba(${Math.round(r*f)},${Math.round(g*f)},${Math.round(b*f)},1)`;
      };

      const dataSet = {
        label: "SUPERHERO",
        tree,
        key: "area",
        groups: ["displayValue"],   // 타일 안 라벨(두 줄)
        spacing: 2,
        borderWidth: 1,
        borderColor: "rgba(10,10,10,0.9)",
        backgroundColor
      };

      const options = {
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              title: (items) => {
                const raw = items[0].raw || {};
                return raw.symbol || "";
              },
              label: (item) => {
                const raw = item.raw || {};
                return [
                  `변동성: ${(+raw.vol).toFixed(2)}%`,
                  `거래대금: ${formatCompact(raw.area)} USDT`
                ];
              }
            }
          }
        },
        layout: { padding: 3 }
      };

      if (treemapChart) {
        treemapChart.data.datasets[0] = dataSet;
        treemapChart.update();
      } else {
        treemapChart = new Chart(ctx, { type: 'treemap', data: { datasets: [dataSet] }, options });
      }
    }

    // ====== 데이터 가져오기 & 주기 갱신 ======
    async function fetchData(path) {
      const url = API_BASE + path;
      const res = await fetch(url, { cache: "no-store" });
      return await res.json();
    }

    async function refresh() {
      updateTimeLabel();
      secondsToNextUpdate = 60;

      const path = endpointSel.value;
      let raw;
      try {
        raw = await fetchData(path);
      } catch (_) {
        if (treemapChart) { treemapChart.destroy(); treemapChart = null; }
        return;
      }
      const data = normalizeData(raw, path);
      renderTreemap(data);
    }

    // 최초 실행 & 인터벌
    refresh();
    startCountdown();
    setInterval(refresh, 60 * 1000);

    // 엔드포인트 전환 즉시 갱신
    endpointSel.addEventListener("change", refresh);

    // 창 크기 변해도 고정 사이즈 캔버스로 다시 그림
    window.addEventListener("resize", () => refresh());
  </script>
</body>
</html>
