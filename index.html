<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>SUPERHERO Treemap — Volatility × Turnover (Auto 60s)</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@2.3.0/dist/chartjs-chart-treemap.min.js"></script>

  <style>
    :root { --scale: 0.70; }
    html, body { margin:0; padding:0; background:#000; color:#fff; font-family:system-ui,-apple-system,Roboto,sans-serif; overflow:hidden; width:100vw; height:100vh; }
    body { transform:scale(var(--scale)); transform-origin:top left; width:calc(100%/var(--scale)); height:calc(100%/var(--scale)); padding:calc(28px/var(--scale)); }
    h1 { font-size:24px; margin:0 0 12px 0; }
    .row { display:flex; gap:16px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
    label, select { font-size:14px; color:#ddd; }
    select { background:#111; color:#fff; border:1px solid #333; border-radius:6px; padding:6px 10px; outline:none; }
    #time { font-size:14px; color:#aaa; }
    #countdown { margin-left:12px; color:#888; }

    :root { --treemap-w: 1280px; --treemap-h: 720px; }
    #chartWrap { width:var(--treemap-w); height:var(--treemap-h); }
    #chart-area { width:var(--treemap-w); height:var(--treemap-h); display:block; border:1px solid #222; border-radius:10px; }

    .legend { font-size:12px; color:#bbb; display:flex; gap:16px; align-items:center; }
    .chip { width:14px; height:14px; border-radius:3px; display:inline-block; margin-right:6px; border:1px solid #333; }
    .chip.up { background:#afff00; } .chip.down { background:#f73f21; }
  </style>
</head>
<body>
  <h1>■ SUPERHERO 실시간 트리맵 (면적=거래대금, 색상=등락, 진하기=변동성) ■</h1>

  <div class="row">
    <div class="legend">
      <span><span class="chip up"></span>상승</span>
      <span><span class="chip down"></span>하락</span>
      <span>진하기 ↑ = 변동성(%) ↑</span>
      <span>면적 ↑ = 거래대금(USDT) ↑</span>
    </div>
  </div>

  <div class="row">
    <label for="endpoint">엔드포인트:</label>
    <select id="endpoint">
      <option value="/top_volatility_1m">1분 변동성</option>
      <option value="/top_volatility_5m" selected>5분 변동성</option>
      <option value="/top_volatility_15m">15분 변동성</option>
      <option value="/top_volatility_1h">1시간 변동성</option>
      <option value="/top_spike_1h_recent">신규코인 급등(1H)</option>
      <option value="/top_dump_1h_recent">신규코인 급락(1H)</option>
      <option value="/top_spike_1h_all">전종목 급등(1H)</option>
      <option value="/top_dump_1h_all">전종목 급락(1H)</option>
    </select>
    <span id="time">UTC 로딩 중...</span>
    <span id="countdown">다음 갱신까지 60s</span>
  </div>

  <div id="chartWrap">
    <canvas id="chart-area"></canvas>
  </div>

  <script>
    const API_BASE = "https://binance-flask-app-production.up.railway.app";
    const endpointSel = document.getElementById("endpoint");
    let secondsToNextUpdate = 60;

    function updateTimeLabel(){ const n=new Date(); const y=n.getUTCFullYear(); const m=String(n.getUTCMonth()+1).padStart(2,'0'); const d=String(n.getUTCDate()).padStart(2,'0'); const h=String(n.getUTCHours()).padStart(2,'0'); const mm=String(n.getUTCMinutes()).padStart(2,'0'); document.getElementById("time").textContent=`${y}-${m}-${d} ${h}:${mm} UTC`; }
    function startCountdown(){ setInterval(()=>{ secondsToNextUpdate--; if(secondsToNextUpdate<=0) secondsToNextUpdate=60; document.getElementById("countdown").textContent=`다음 갱신까지 ${secondsToNextUpdate}s`; },1000); }

    const fmtPct = v => `${(+v).toFixed(2)}%`;
    function formatCompact(num){ const n=+num||0; if(n>=1e12) return (n/1e12).toFixed(2)+"T"; if(n>=1e9) return (n/1e9).toFixed(2)+"B"; if(n>=1e6) return (n/1e6).toFixed(2)+"M"; if(n>=1e3) return (n/1e3).toFixed(2)+"K"; return n.toFixed(0); }
    const colorBaseHex = c => (c==="green" ? "#2db84d" : "#c6453a");
    function intensity(volPct,maxVol){ if(maxVol<=0) return 0.6; const r=Math.max(0,Math.min(1,volPct/maxVol)); return 0.30+r*0.70; }

    function normalizeData(raw, endpointPath){
      const arr = Array.isArray(raw) ? raw : (Array.isArray(raw?.data) ? raw.data : []);
      const isSpike = endpointPath.includes("_spike_");
      const isDump  = endpointPath.includes("_dump_");
      return arr.map(d=>{
        let vol=0, volUSD=0, col=d.color;
        if("volatility" in d){ vol=+d.volatility||0; volUSD=+d.volume_usdt||0; }
        else { if(isSpike) vol=+d.spike_pct||0; if(isDump) vol=+d.dump_pct||0; volUSD=+d.volume_usdt_1h||0; }
        const sym=d.symbol||d.futures_symbol||d.name||"NA";
        return { symbol:sym, volatility:vol, volume_usdt:volUSD, color:col||"green" };
      }).filter(d=>d.symbol && d.volume_usdt>=0 && d.volatility>=0);
    }

    const TREEMAP_MAX_ITEMS=28, MIN_AREA_RATIO=0.01;
    function selectForLayout(data, w, h){
      const total=data.reduce((s,d)=>s+(d.volume_usdt||0),0);
      const area=w*h, minArea=area*MIN_AREA_RATIO;
      const sorted=data.slice().sort((a,b)=>(b.volume_usdt||0)-(a.volume_usdt||0));
      const picked=[];
      for(const d of sorted){
        if(picked.length>=TREEMAP_MAX_ITEMS) break;
        const est= total>0 ? (d.volume_usdt/total)*area : 0;
        if(est>=minArea) picked.push(d);
      }
      if(!picked.length && sorted.length) picked.push(sorted[0]);
      return {picked, total};
    }

    let treemapChart=null;
    function renderTreemap(data){
      const w=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-w'));
      const h=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-h'));

      const {picked, total} = selectForLayout(data, w, h);
      const maxVol = Math.max(...picked.map(d=>d.volatility||0), 0);

      // tree 데이터 + 라벨 텍스트
      const tree = picked.map(d=>{
        const sign = d.color==='green' ? '+' : '−';
        return {
          symbol: d.symbol,
          area: d.volume_usdt,
          vol: d.volatility,
          color: d.color,
          displayValue: `${d.symbol}\n${sign}${d.volatility.toFixed(2)}%`,
          _data: { w: w*(d.volume_usdt/Math.max(total,1)), h } // 라벨 폰트 산정용 대략치
        };
      });

      const ctx=document.getElementById("chart-area").getContext("2d");

      const backgroundColor = (c)=>{
        const raw=c.raw||{};
        const base=colorBaseHex(raw.color||"green");
        const r=parseInt(base.slice(1,3),16);
        const g=parseInt(base.slice(3,5),16);
        const b=parseInt(base.slice(5,7),16);
        const f=intensity(raw.vol||0,maxVol);
        return `rgba(${Math.round(r*f)},${Math.round(g*f)},${Math.round(b*f)},1)`;
      };

      const dataSet = {
  label: "SUPERHERO",
  tree,
  key: "area",
  // groups: ["displayValue"],   // ⛔️ 제거 (그룹 라벨로 뭉개지면서 안 보였던 원인)
  spacing: 2,
  borderWidth: 1,
  borderColor: "rgba(10,10,10,0.9)",
  backgroundColor,

  // ✅ 중앙 2줄 라벨 (심볼 + 퍼센트)
  labels: {
    display: true,
    formatter: ({ raw }) => {
      const sign = raw.color === "green" ? "+" : "−";
      const pct  = (raw.vol ?? raw.volatility ?? 0);
      return `${raw.symbol}\n${sign}${(+pct).toFixed(2)}%`;
    },
    color: "#eef2f6",
    align: "center",
    // 동적 ctx.raw._data 의존 X → 안정적 표기
    font: { size: 18, weight: "800" },
    minFontSize: 10,
    lineHeight: 1.15,
    padding: 2,
    overflow: "hidden"
  }
};


      const options={
        maintainAspectRatio:false,
        plugins:{
          legend:{ display:false },
          tooltip:{
            callbacks:{
              title:(items)=> (items[0].raw?.symbol)||'',
              label:(item)=>{
                const raw=item.raw||{};
                return [`변동성: ${(+raw.vol).toFixed(2)}%`, `거래대금: ${formatCompact(raw.area)} USDT`];
              }
            }
          }
        },
        layout:{ padding:3 }
      };

      if(treemapChart){
        treemapChart.data.datasets[0]=dataSet;
        treemapChart.update();
      }else{
        treemapChart = new Chart(ctx, { type:'treemap', data:{ datasets:[dataSet] }, options });
      }
    }

    async function fetchData(path){ const res=await fetch(API_BASE+path,{cache:"no-store"}); return await res.json(); }

    async function refresh(){
      updateTimeLabel(); secondsToNextUpdate=60;
      const path=endpointSel.value;
      let raw;
      try{ raw=await fetchData(path); }
      catch(_){ if(treemapChart){ treemapChart.destroy(); treemapChart=null; } return; }
      const data=normalizeData(raw,path);
      renderTreemap(data);
    }

    refresh(); startCountdown(); setInterval(refresh, 60*1000);
    endpointSel.addEventListener("change", refresh);
    window.addEventListener("resize", ()=>refresh());
  </script>
</body>
</html>
