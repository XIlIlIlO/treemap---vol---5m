<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>SUPERHERO Treemap — Volatility × Turnover (Auto 60s)</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@2.3.0/dist/chartjs-chart-treemap.min.js"></script>

  <style>
    :root { --scale: 0.70; }
    html, body { margin:0; padding:0; background:#000; color:#fff; font-family:system-ui,-apple-system,Roboto,sans-serif; overflow:hidden; width:100vw; height:100vh; }
    body { transform:scale(var(--scale)); transform-origin:top left; width:calc(100%/var(--scale)); height:calc(100%/var(--scale)); padding:calc(28px/var(--scale)); }
    h1 { font-size:24px; margin:0 0 12px 0; }
    .row { display:flex; gap:16px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
    label, select { font-size:14px; color:#ddd; }
    select { background:#111; color:#fff; border:1px solid #333; border-radius:6px; padding:6px 10px; outline:none; }
    #time { font-size:14px; color:#aaa; }
    #countdown { margin-left:12px; color:#888; }

    :root { --treemap-w: 1280px; --treemap-h: 720px; }
    #chartWrap { width:var(--treemap-w); height:var(--treemap-h); }
    #chart-area { width:var(--treemap-w); height:var(--treemap-h); display:block; border:1px solid #222; border-radius:10px; }

    .legend { font-size:12px; color:#bbb; display:flex; gap:16px; align-items:center; }
    .chip { width:14px; height:14px; border-radius:3px; display:inline-block; margin-right:6px; border:1px solid #333; }
    .chip.up { background:#afff00; } .chip.down { background:#f73f21; }
  </style>
</head>
<body>
  <h1>■ SUPERHERO 실시간 트리맵 (면적=변동성, 색상=등락, 진하기=거래대금) ■</h1>

  <div class="row">
    <div class="legend">
      <span><span class="chip up"></span>상승</span>
      <span><span class="chip down"></span>하락</span>
      <span>진하기 ↑ = 거래대금(USDT) ↑</span>
      <span>면적 ↑ = 변동성(%) ↑</span>
    </div>
  </div>

  <div class="row">
    <label for="endpoint">엔드포인트:</label>
    <select id="endpoint">
      <option value="/top_volatility_1m">1분 변동성</option>
      <option value="/top_volatility_5m" selected>5분 변동성</option>
      <option value="/top_volatility_15m">15분 변동성</option>
      <option value="/top_volatility_1h">1시간 변동성</option>
      <option value="/top_spike_1h_recent">신규코인 급등(1H)</option>
      <option value="/top_dump_1h_recent">신규코인 급락(1H)</option>
      <option value="/top_spike_1h_all">전종목 급등(1H)</option>
      <option value="/top_dump_1h_all">전종목 급락(1H)</option>
    </select>
    <span id="time">UTC 로딩 중...</span>
    <span id="countdown">다음 갱신까지 60s</span>
  </div>

  <div id="chartWrap">
    <canvas id="chart-area"></canvas>
  </div>

  <script>
    const API_BASE = "https://binance-flask-app-production.up.railway.app";
    const endpointSel = document.getElementById("endpoint");
    let secondsToNextUpdate = 60;

    function updateTimeLabel(){
      const n=new Date(); const y=n.getUTCFullYear();
      const m=String(n.getUTCMonth()+1).padStart(2,'0');
      const d=String(n.getUTCDate()).padStart(2,'0');
      const h=String(n.getUTCHours()).padStart(2,'0');
      const mm=String(n.getUTCMinutes()).padStart(2,'0');
      document.getElementById("time").textContent=`${y}-${m}-${d} ${h}:${mm} UTC`;
    }
    function startCountdown(){
      setInterval(()=>{ secondsToNextUpdate--; if(secondsToNextUpdate<=0) secondsToNextUpdate=60;
        document.getElementById("countdown").textContent=`다음 갱신까지 ${secondsToNextUpdate}s`; },1000);
    }

    const fmtPct = v => `${(Number(v)||0).toFixed(2)}%`;
    function formatCompact(num){
      const n=+num||0;
      if(n>=1e12) return (n/1e12).toFixed(2)+"T";
      if(n>=1e9)  return (n/1e9 ).toFixed(2)+"B";
      if(n>=1e6)  return (n/1e6 ).toFixed(2)+"M";
      if(n>=1e3)  return (n/1e3 ).toFixed(2)+"K";
      return n.toFixed(0);
    }
    const GREEN = "#2db84d";
    const RED   = "#c6453a";
    const colorBaseHexFromVol = vol => (Number(vol) >= 0 ? GREEN : RED);

    // ── 원시 데이터 정규화
    function normalizeData(raw, endpointPath){
      const arr = Array.isArray(raw) ? raw : (Array.isArray(raw?.data) ? raw.data : []);
      const isSpike = endpointPath.includes("_spike_");
      const isDump  = endpointPath.includes("_dump_");
      return arr.map(d=>{
        let vol=0, volUSD=0;
        if("volatility" in d){ vol=Number(d.volatility)||0; volUSD=Number(d.volume_usdt)||0; }
        else { if(isSpike) vol=Number(d.spike_pct)||0; if(isDump) vol=Number(d.dump_pct)||0; volUSD=Number(d.volume_usdt_1h)||0; }
        const sym=d.symbol||d.futures_symbol||d.name||"NA";
        // 색상은 '부호'로 직접 산정 (API color 무시/보정)
        const col = vol >= 0 ? "green" : "red";
        return { symbol:sym, volatility:vol, volume_usdt:volUSD, color:col };
      }).filter(d=>d.symbol);
    }

    // ── 레이아웃 선택(면적=변동성)
    const TREEMAP_MAX_ITEMS=28, MIN_AREA_RATIO=0.01;
    function selectForLayout(data, w, h){
      const areaMetric = d => Math.abs(Number(d.volatility)||0);  // 면적 기준 = |변동성|
      const totalAreaMetric = data.reduce((s,d)=>s+areaMetric(d),0);
      const area = w*h, minArea = area*MIN_AREA_RATIO;

      const sorted = data.slice().sort((a,b)=>areaMetric(b)-areaMetric(a));
      const picked = [];
      for(const d of sorted){
        if(picked.length>=TREEMAP_MAX_ITEMS) break;
        const est = totalAreaMetric>0 ? (areaMetric(d)/totalAreaMetric)*area : 0;
        if(est>=minArea) picked.push(d);
      }
      if(!picked.length && sorted.length) picked.push(sorted[0]);
      return {picked, totalAreaMetric};
    }

    let treemapChart=null;

    function renderTreemap(data){
      const w=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-w'));
      const h=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-h'));

      const {picked, totalAreaMetric} = selectForLayout(data, w, h);

      // ── 진하기: 거래대금 log 스케일 정규화
      const turnovers = picked.map(d => Math.max(0, Number(d.volume_usdt)||0));
      const logVals = turnovers.map(v => Math.log1p(v));
      const logMin = Math.min(...logVals, 0);
      const logMax = Math.max(...logVals, 1);
      const normTurnover = v => {
        const t = Math.log1p(Math.max(0, Number(v)||0));
        return (t - logMin) / Math.max(1e-9, (logMax - logMin)); // 0~1
      };

      // tree 데이터 구성
      const tree = picked.map(d=>{
        const vol = Number(d.volatility)||0;
        const sign = vol >= 0 ? '+' : '−';
        const areaVal = Math.max(0.001, Math.abs(vol)); // 0 보호
        const turnover = Math.max(0, Number(d.volume_usdt)||0);
        const displayValue = `${d.symbol} ${sign}${Math.abs(vol).toFixed(2)}%`;
        return {
          symbol: d.symbol,
          area: areaVal,                 // ✔ 면적 = 변동성(|vol|)
          vol,
          turnover,
          color: vol >= 0 ? "green" : "red",
          displayValue,
          _data: { w: w*(areaVal/Math.max(totalAreaMetric,1)), h }
        };
      });

      const ctx=document.getElementById("chart-area").getContext("2d");

      // ✔ 배경색 진하기 = 거래대금 비례(로그 정규화, 0.50~0.98)
      const backgroundColor = (c)=>{
        const raw=c.raw||{};
        const base=colorBaseHexFromVol(raw.vol);
        const r=parseInt(base.slice(1,3),16);
        const g=parseInt(base.slice(3,5),16);
        const b=parseInt(base.slice(5,7),16);
        const f = 0.50 + 0.48 * normTurnover(raw.turnover);
        return `rgba(${Math.round(r*f)},${Math.round(g*f)},${Math.round(b*f)},1)`;
      };

      const dataSet = {
        label:"SUPERHERO",
        tree,
        key:"area",                       // ✔ 면적 = area(변동성)
        groups:["displayValue"],          // ✔ 라벨 텍스트 소스
        spacing:2,
        borderWidth:1,
        borderColor:"rgba(10,10,10,0.9)",
        backgroundColor,
        labels:{
          display:true,
          formatter:(ctx)=>{
            const r = ctx.raw || {};
            return r.displayValue || r.g || r.symbol || "";
          },
          color:'#eef2f6',
          align:'center',
          font:(ctx)=>{
            const r = ctx.raw || {};
            const approxW = r._data?.w || 80;
            const approxH = r._data?.h || 60;
            const base = Math.min(approxW, approxH);
            const size = Math.max(12, Math.min(48, base*0.16));
            return { size, weight:'800', lineHeight:1.15 };
          },
          padding:2,
          overflow:'hidden'
        }
      };

      const options={
        maintainAspectRatio:false,
        plugins:{
          legend:{ display:false },
          tooltip:{
            callbacks:{
              title:(items)=> (items[0].raw?.symbol)||'',
              label:(item)=>{
                const raw=item.raw||{};
                const v = Number(raw.vol) || 0;
                const t = Number(raw.turnover) || 0;
                return [
                  `변동성(면적): ${fmtPct(v)}`,
                  `거래대금(진하기): ${formatCompact(t)} USDT`
                ];
              }
            }
          }
        },
        layout:{ padding:3 }
      };

      if(treemapChart){
        treemapChart.data.datasets[0]=dataSet;
        treemapChart.update();
      }else{
        treemapChart = new Chart(ctx, { type:'treemap', data:{ datasets:[dataSet] }, options });
      }
    }

    async function fetchData(path){ const res=await fetch(API_BASE+path,{cache:"no-store"}); return await res.json(); }

    async function refresh(){
      updateTimeLabel(); secondsToNextUpdate=60;
      const path=endpointSel.value;
      let raw;
      try{ raw=await fetchData(path); }
      catch(_){ if(treemapChart){ treemapChart.destroy(); treemapChart=null; } return; }
      const data=normalizeData(raw,path);
      renderTreemap(data);
    }

    refresh(); startCountdown(); setInterval(refresh, 60*1000);
    endpointSel.addEventListener("change", refresh);
    window.addEventListener("resize", ()=>refresh());
  </script>
</body>
</html>
