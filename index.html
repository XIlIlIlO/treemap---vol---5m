<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>SUPERHERO Treemap — Volatility × Turnover (Auto 60s)</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@2.3.0/dist/chartjs-chart-treemap.min.js"></script>

  <style>
    :root { --scale: 0.70; }
    html, body { margin:0; padding:0; background:#000; color:#fff; font-family:system-ui,-apple-system,Roboto,sans-serif; overflow:hidden; width:100vw; height:100vh; }
    body { transform:scale(var(--scale)); transform-origin:top left; width:calc(100%/var(--scale)); height:calc(100%/var(--scale)); padding:calc(28px/var(--scale)); }
    h1 { font-size:24px; margin:0 0 12px 0; }
    .row { display:flex; gap:16px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
    label, select { font-size:14px; color:#ddd; }
    select { background:#111; color:#fff; border:1px solid #333; border-radius:6px; padding:6px 10px; outline:none; }
    #time { font-size:14px; color:#aaa; }
    #countdown { margin-left:12px; color:#888; }

    :root { --treemap-w: 1280px; --treemap-h: 720px; }
    #chartWrap { width:var(--treemap-w); height:var(--treemap-h); }
    #chart-area { width:var(--treemap-w); height:var(--treemap-h); display:block; border:1px solid #222; border-radius:10px; }

    .legend { font-size:12px; color:#bbb; display:flex; gap:16px; align-items:center; }
    .chip { width:14px; height:14px; border-radius:3px; display:inline-block; margin-right:6px; border:1px solid #333; }
    .chip.up { background:#afff00; } .chip.down { background:#f73f21; }
  </style>
</head>
<body>
  <h1>■ SUPERHERO 실시간 트리맵 (면적=변동성, 색상=등락, 진하기=거래대금) ■</h1>

  <div class="row">
    <div class="legend">
      <span><span class="chip up"></span>상승</span>
      <span><span class="chip down"></span>하락</span>
      <span>진하기 ↑ = 거래대금(USDT) ↑</span>
      <span>면적 ↑ = 변동성(%) ↑</span>
    </div>
  </div>

  <div class="row">
    <label for="endpoint">엔드포인트:</label>
    <select id="endpoint">
      <option value="/top_volatility_1m">1분 변동성</option>
      <option value="/top_volatility_5m" selected>5분 변동성</option>
      <option value="/top_volatility_15m">15분 변동성</option>
      <option value="/top_volatility_1h">1시간 변동성</option>
      <option value="/top_spike_1h_recent">신규코인 급등(1H)</option>
      <option value="/top_dump_1h_recent">신규코인 급락(1H)</option>
      <option value="/top_spike_1h_all">전종목 급등(1H)</option>
      <option value="/top_dump_1h_all">전종목 급락(1H)</option>
    </select>
    <span id="time">UTC 로딩 중...</span>
    <span id="countdown">다음 갱신까지 60s</span>
  </div>

  <div id="chartWrap">
    <canvas id="chart-area"></canvas>
  </div>

  <script>
  const API_BASE = "https://binance-flask-app-production.up.railway.app";
  const endpointSel = document.getElementById("endpoint");
  let secondsToNextUpdate = 60;

  const HEX = { green:"#2db84d", red:"#c6453a", gray:"#444444" };

  const fmtPct = v => `${(Number(v)||0).toFixed(2)}%`;
  const formatCompact = n => {
    const v = +n || 0;
    if(v>=1e12) return (v/1e12).toFixed(2)+"T";
    if(v>=1e9)  return (v/1e9 ).toFixed(2)+"B";
    if(v>=1e6)  return (v/1e6 ).toFixed(2)+"M";
    if(v>=1e3)  return (v/1e3 ).toFixed(2)+"K";
    return v.toFixed(0);
  };

  function updateTimeLabel(){
    const n=new Date(); const y=n.getUTCFullYear();
    const m=String(n.getUTCMonth()+1).padStart(2,'0');
    const d=String(n.getUTCDate()).padStart(2,'0');
    const h=String(n.getUTCHours()).padStart(2,'0');
    const mm=String(n.getUTCMinutes()).padStart(2,'0');
    document.getElementById("time").textContent=`${y}-${m}-${d} ${h}:${mm} UTC`;
  }
  function startCountdown(){
    setInterval(()=>{ secondsToNextUpdate--; if(secondsToNextUpdate<=0) secondsToNextUpdate=60;
      document.getElementById("countdown").textContent=`다음 갱신까지 ${secondsToNextUpdate}s`; },1000);
  }

  // ─────────────────────────────────────────────────
  // 1) 원시 데이터 정규화 (키 자동 매핑)
  function normalizeData(raw, endpointPath){
    const arr = Array.isArray(raw) ? raw : (Array.isArray(raw?.data) ? raw.data : []);
    const isSpike = endpointPath.includes("_spike_");
    const isDump  = endpointPath.includes("_dump_");

    return arr.map(d=>{
      let vol = 0;
      if ("volatility" in d) vol = Number(d.volatility)||0;
      else if (isSpike) vol = Number(d.spike_pct)||0;
      else if (isDump)  vol = Number(d.dump_pct)||0;

      const volUSD = Number(d.volume_usdt ?? d.volume_usdt_1h ?? 0) || 0;

      const sym = d.symbol || d.futures_symbol || d.name || "NA";
      const rawColor = (d.color || d.color_1h || "").toLowerCase();
      const colorHex = HEX[rawColor] || (vol >= 0 ? HEX.green : HEX.red);

      return { symbol: sym, volatility: vol, volume_usdt: volUSD, colorHex, rawColor };
    }).filter(d=>d.symbol);
  }

  // ─────────────────────────────────────────────────
  // 2) 레이아웃(면적=|변동성|)
  const TREEMAP_MAX_ITEMS=28, MIN_AREA_RATIO=0.01;
  function selectForLayout(data, w, h){
    const areaMetric = d => Math.abs(Number(d.volatility)||0);
    const totalAreaMetric = data.reduce((s,d)=>s+areaMetric(d),0);
    const area = w*h, minArea = area*MIN_AREA_RATIO;

    const sorted = data.slice().sort((a,b)=>areaMetric(b)-areaMetric(a));
    const picked = [];
    for(const d of sorted){
      if(picked.length>=TREEMAP_MAX_ITEMS) break;
      const est = totalAreaMetric>0 ? (areaMetric(d)/totalAreaMetric)*area : 0;
      if(est>=minArea) picked.push(d);
    }
    if(!picked.length && sorted.length) picked.push(sorted[0]);
    return {picked, totalAreaMetric};
  }

  // ─────────────────────────────────────────────────
  // 3) 진하기 정규화: 로그 + 5~95% 퍼센타일 클리핑
  function percentile(arr, p){
    if(!arr.length) return 0;
    const s = arr.slice().sort((a,b)=>a-b);
    const i = Math.min(s.length-1, Math.max(0, Math.floor((p/100)*(s.length-1))));
    return s[i];
  }
  function makeTurnoverNormalizer(values){
    if(!values.length) return ()=>0.6;
    const logs = values.map(v=>Math.log1p(Math.max(0,+v||0)));
    const lo = percentile(logs,5), hi = percentile(logs,95);
    const den = Math.max(1e-9, hi-lo);
    return v=>{
      const z = (Math.log1p(Math.max(0,+v||0)) - lo)/den;
      return Math.max(0, Math.min(1, z)); // 0~1
    };
  }

  // RGB↔HSL 도우미 (Lightness만 조정)
  function hexToRgb(hex){ const h=hex.replace("#",""); return {
    r:parseInt(h.slice(0,2),16), g:parseInt(h.slice(2,4),16), b:parseInt(h.slice(4,6),16)
  };}
  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0,s=0,l=(max+min)/2;
    if(max!==min){
      const d=max-min;
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h=(g-b)/d + (g<b?6:0); break;
        case g: h=(b-r)/d + 2; break;
        case b: h=(r-g)/d + 4; break;
      }
      h/=6;
    }
    return {h,s,l};
  }
  function hslToRgb(h,s,l){
    let r,g,b;
    if(s===0){ r=g=b=l; }
    else{
      const hue2rgb=(p,q,t)=>{
        if(t<0) t+=1; if(t>1) t-=1;
        if(t<1/6) return p+(q-p)*6*t;
        if(t<1/2) return q;
        if(t<2/3) return p+(q-p)*(2/3 - t)*6;
        return p;
      };
      const q = l<0.5 ? l*(1+s) : l+s-l*s;
      const p = 2*l-q;
      r=hue2rgb(p,q,h+1/3); g=hue2rgb(p,q,h); b=hue2rgb(p,q,h-1/3);
    }
    return {r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255)};
  }

  let treemapChart=null;

  function renderTreemap(data){
    const w=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-w'));
    const h=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-h'));
    const {picked, totalAreaMetric} = selectForLayout(data, w, h);

    const turnovers = picked.map(d=>Math.max(0, Number(d.volume_usdt)||0));
    const norm = makeTurnoverNormalizer(turnovers); // 0~1

    const tree = picked.map(d=>{
    const vol = Number(d.volatility)||0;
    const areaVal = Math.max(0.001, Math.abs(vol));   // 면적 값
    const turnover = Math.max(0, Number(d.volume_usdt)||0);
    const sign = (d.rawColor === 'red' ? '−' : '+');
    const displayValue = `${d.symbol} ${sign}${Math.abs(vol).toFixed(2)}%`;
    return {
      // ✅ treemap 표준 키
      g: displayValue,       // 라벨
      v: areaVal,            // 면적
      // ✅ 커스텀 값은 전부 _m 안에 보존
      _m: {
        symbol: d.symbol,
        vol,
        turnover,
        colorHex: d.colorHex,
        rawColor: d.rawColor,
        approxW: w*(areaVal/Math.max(totalAreaMetric,1)),
        approxH: h
      }
    };
  });

    const ctx=document.getElementById("chart-area").getContext("2d");

      const backgroundColor = (c)=>{
    const raw = c.raw?._m || {};
    const {r,g,b} = hexToRgb(raw.colorHex || "#2db84d");
      const {h,s} = rgbToHsl(r,g,b);
      const l = 0.35 + 0.43 * norm(raw.turnover); // Lightness 35%~78%
      const rgb = hslToRgb(h,s,l);
      return `rgba(${rgb.r},${rgb.g},${rgb.b},1)`;
    };

    const dataSet = {
      label:"SUPERHERO",
      tree,
      key:"v",            // ✅ 면적 키
      groups:["g"],       // ✅ 라벨 키
      spacing:2,
      borderWidth:1,
      borderColor:"rgba(10,10,10,0.9)",
      backgroundColor,
      labels:{
        display:true,
         formatter:(ctx)=> ctx.raw?.g || "",
        color:'#eef2f6',
        align:'center',
        font:(ctx)=>{
          const r = ctx.raw || {};
          const base = Math.min(r._data?.w||80, r._data?.h||60);
          const size = Math.max(12, Math.min(48, base*0.16));
          return { size, weight:'800', lineHeight:1.15 };
        },
        padding:2,
        overflow:'hidden'
      }
    };

    const options={
      maintainAspectRatio:false,
      plugins:{
        legend:{ display:false },
        tooltip:{
          callbacks:{
            title:(items)=> (items[0].raw?._m?.symbol)||'',
            label:(item)=>{
              const raw=item.raw?._m||{};
              return [
                `변동성(면적): ${fmtPct(+raw.vol||0)}`,
                `거래대금(진하기): ${formatCompact(+raw.turnover||0)} USDT`
              ];
            }
          }
        }
      },
      layout:{ padding:3 }
    };

    if(treemapChart){ treemapChart.data.datasets[0]=dataSet; treemapChart.update(); }
    else{ treemapChart = new Chart(ctx, { type:'treemap', data:{ datasets:[dataSet] }, options }); }
  }

  async function fetchData(path){
    const res=await fetch(API_BASE+path,{cache:"no-store"});
    return await res.json();
  }
  function updateTimeLabelWrap(){ updateTimeLabel(); }

  async function refresh(){
    updateTimeLabelWrap(); secondsToNextUpdate=60;
    const path=endpointSel.value;
    let raw;
    try{ raw=await fetchData(path); }
    catch(_){ if(treemapChart){ treemapChart.destroy(); treemapChart=null; } return; }
    const data=normalizeData(raw,path);
    renderTreemap(data);
  }

  refresh(); startCountdown(); setInterval(refresh, 60*1000);
  endpointSel.addEventListener("change", refresh);
  window.addEventListener("resize", ()=>refresh());
</script>

</body>
</html>
