<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>SUPERHERO Treemap — Volatility × Turnover (Auto 60s)</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root { --scale: 0.70; }

    html, body {
      margin: 0; padding: 0;
      background: #000; color: #fff; font-family: system-ui, -apple-system, Roboto, sans-serif;
      overflow: hidden; width: 100vw; height: 100vh;
    }
    body {
      transform: scale(var(--scale));
      transform-origin: top left;
      width: calc(100% / var(--scale));
      height: calc(100% / var(--scale));
      padding: calc(28px / var(--scale));
    }

    h1 { font-size: 24px; margin: 0 0 12px 0; }
    .row { display: flex; gap: 16px; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
    label, select { font-size: 14px; color: #ddd; }
    select {
      background: #111; color: #fff; border: 1px solid #333; border-radius: 6px; padding: 6px 10px;
      outline: none;
    }
    #time { font-size: 14px; color: #aaa; }
    #countdown { margin-left: 12px; color: #888; }

    /* ▼▼▼ 트리맵 '고정 사이즈' (필요 시 값만 변경) ▼▼▼ */
    :root { --treemap-w: 1280px; --treemap-h: 720px; }
    #chartWrap { width: var(--treemap-w); height: var(--treemap-h); /* 상단 영역 제외 X: 트리맵만 고정 */ }
    #chart     { width: var(--treemap-w); height: var(--treemap-h); display: block; border: 1px solid #222; border-radius: 10px; }
    /* ▲▲▲ */

    .cell { cursor: pointer; }
    /* 샘플 이미지처럼 각진 모서리 + 얇은 경계 */
    .cell rect { rx: 2; ry: 2; stroke: #0f1115; stroke-width: 1; }

    /* 큰/중 타일 중앙 라벨 */
    .label-center{
      fill:#f7f9fb; font-weight:800; text-anchor:middle;
      paint-order:stroke; stroke:rgba(0,0,0,.35); stroke-width:3px; stroke-linejoin:round;
    }
    .pct-center{
      fill:#eef2f6; font-weight:700; text-anchor:middle;
      paint-order:stroke; stroke:rgba(0,0,0,.28); stroke-width:2px; stroke-linejoin:round;
    }

    /* 작은 타일 좌상단 라벨 */
    .tiny{
      fill:#e6ebf2; font-weight:700; font-size:11px;
      paint-order:stroke; stroke:rgba(0,0,0,.25); stroke-width:2px; stroke-linejoin:round;
    }

    .tooltip {
      position: fixed; pointer-events: none; z-index: 50;
      background: rgba(15,15,15,0.92); color: #fff; border: 1px solid #333; border-radius: 8px;
      padding: 10px 12px; font-size: 13px; line-height: 1.45;
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      display:none; opacity:0;
    }
    .legend { font-size: 12px; color: #bbb; display:flex; gap:16px; align-items:center; }
    .chip { width:14px; height:14px; border-radius: 3px; display:inline-block; margin-right:6px; border:1px solid #333; }
    .chip.up { background:#afff00; }
    .chip.down { background:#f73f21; }
  </style>
</head>
<body>
  <h1>■ SUPERHERO 실시간 트리맵 (면적=거래대금, 색상=등락, 진하기=변동성) ■</h1>

  <div class="row">
    <div class="legend">
      <span><span class="chip up"></span>상승</span>
      <span><span class="chip down"></span>하락</span>
      <span>진하기 ↑ = 변동성(%) ↑</span>
      <span>면적 ↑ = 거래대금(USDT) ↑</span>
    </div>
  </div>

  <div class="row">
    <label for="endpoint">엔드포인트:</label>
    <select id="endpoint">
      <!-- 변동성 랭킹 계열 -->
      <option value="/top_volatility_1m">1분 변동성</option>
      <option value="/top_volatility_5m" selected>5분 변동성</option>
      <option value="/top_volatility_15m">15분 변동성</option>
      <option value="/top_volatility_1h">1시간 변동성</option>
      <!-- 신규코인 급등/급락 (≤6개월) -->
      <option value="/top_spike_1h_recent">신규코인 급등(1H)</option>
      <option value="/top_dump_1h_recent">신규코인 급락(1H)</option>
      <!-- 전종목 급등/급락 -->
      <option value="/top_spike_1h_all">전종목 급등(1H)</option>
      <option value="/top_dump_1h_all">전종목 급락(1H)</option>
    </select>

    <span id="time">UTC 로딩 중...</span>
    <span id="countdown">다음 갱신까지 60s</span>
  </div>

  <div id="chartWrap">
    <svg id="chart"></svg>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script>
    // ====== 기본 API 베이스 ======
    const API_BASE = "https://binance-flask-app-production.up.railway.app";

    // ====== 셀렉터와 UI 타이머 ======
    const endpointSel = document.getElementById("endpoint");
    let secondsToNextUpdate = 60;

    function updateTimeLabel() {
      const now = new Date();
      const y = now.getUTCFullYear();
      const m = String(now.getUTCMonth() + 1).padStart(2, '0');
      const d = String(now.getUTCDate()).padStart(2, '0');
      const h = String(now.getUTCHours()).padStart(2, '0');
      const mm = String(now.getUTCMinutes()).padStart(2, '0');
      document.getElementById("time").textContent = `${y}-${m}-${d} ${h}:${mm} UTC`;
    }
    function startCountdown() {
      setInterval(() => {
        secondsToNextUpdate--;
        if (secondsToNextUpdate <= 0) secondsToNextUpdate = 60;
        document.getElementById("countdown").textContent = `다음 갱신까지 ${secondsToNextUpdate}s`;
      }, 1000);
    }

    // ====== 유틸 ======
    const fmtPct = v => `${(+v).toFixed(2)}%`;
    function formatCompact(num) {
      const n = +num || 0;
      if (n >= 1e12) return (n / 1e12).toFixed(2) + "T";
      if (n >= 1e9)  return (n / 1e9 ).toFixed(2) + "B";
      if (n >= 1e6)  return (n / 1e6 ).toFixed(2) + "M";
      if (n >= 1e3)  return (n / 1e3 ).toFixed(2) + "K";
      return n.toFixed(0);
    }
    const colorBase = c => (c === "green" ? "#afff00" : "#f73f21");

    // 색 진하기를 변동성(%)에 맞춰 보정 (0~1) → 0.30~1.00
    function intensity(volPct, maxVol) {
      if (maxVol <= 0) return 0.6;
      const r = Math.max(0, Math.min(1, volPct / maxVol));
      return 0.30 + r * 0.70;
    }

    // ====== SVG 및 레이아웃 (고정 사이즈) ======
    const svg = d3.select("#chart");
    function sizeSVG() {
      const w = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-w'));
      const h = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-h'));
      svg.attr("width", w).attr("height", h);
      return { w, h };
    }

    // ====== 데이터 표준화 ======
    // 변동성 계열: [{symbol, volatility, color, volume_usdt}]
    // 급등/급락 계열: spike_pct/dump_pct + volume_usdt_1h, color
    function normalizeData(raw, endpointPath) {
      const arr = Array.isArray(raw) ? raw : (Array.isArray(raw?.data) ? raw.data : []);
      const isSpike = endpointPath.includes("_spike_");
      const isDump  = endpointPath.includes("_dump_");
      return arr.map(d => {
        let vol = 0, volUSD = 0, col = d.color;
        if ("volatility" in d) {
          vol = +d.volatility || 0;
          volUSD = +d.volume_usdt || 0;
        } else {
          if (isSpike) vol = +d.spike_pct || 0;
          if (isDump)  vol = +d.dump_pct  || 0;
          volUSD = +d.volume_usdt_1h || 0;
        }
        const sym = d.symbol || d.futures_symbol || d.name || "NA";
        return { symbol: sym, volatility: vol, volume_usdt: volUSD, color: col || "green" };
      }).filter(d => d.symbol && d.volume_usdt >= 0 && d.volatility >= 0);
    }

    /* ======================================================
       ▼▼▼ ① 추가: Treemap 정돈 옵션 & 선택 로직 ▼▼▼
       ====================================================== */
    const TREEMAP_MAX_ITEMS = 10;   // 최대 표출 종목 수
    const MIN_AREA_RATIO    = 0.05; // 전체 영역 대비 최소 5%

    function selectForLayout(data, width, height) {
      const total = d3.sum(data, d => Math.max(0, d.volume_usdt || 0));
      const area  = width * height;
      const minArea = area * MIN_AREA_RATIO;

      const sorted = data.slice().sort((a,b) => (b.volume_usdt||0) - (a.volume_usdt||0));

      const picked = [];
      for (const d of sorted) {
        if (picked.length >= TREEMAP_MAX_ITEMS) break;
        const estArea = total > 0 ? (d.volume_usdt / total) * area : 0;
        if (estArea >= minArea) picked.push(d);
      }
      if (picked.length === 0 && sorted.length) picked.push(sorted[0]);
      return picked;
    }
    /* ======================================================
       ▲▲▲ ① 추가 끝
       ====================================================== */

    // ====== Treemap 렌더링 (샘플 스타일) ======
    const tooltip = document.getElementById("tooltip");
    function showTip(html, x, y) {
      tooltip.innerHTML = html;
      tooltip.style.left = (x + 12) + "px";
      tooltip.style.top  = (y + 12) + "px";
      tooltip.style.opacity = 1;
      tooltip.style.display = "block";
    }
    function hideTip() {
      tooltip.style.opacity = 0;
      tooltip.style.display = "none";
    }

    /* ======================================================
       ▼▼▼ ② 추가/교체: 정돈된 treemapBinary + 필터 ▼▼▼
       ====================================================== */
    function renderTreemap(data) {
      const { w, h } = sizeSVG();
      svg.selectAll("*").remove();
      if (!data.length) return;

      const filtered = selectForLayout(data, w, h);
      const maxVol = d3.max(filtered, d => Math.max(0, d.volatility || 0));

      const root = d3.hierarchy({ name: "root", children: filtered })
        .sum(d => Math.max(0.0001, d.volume_usdt))
        .sort((a,b) =>
          (b.data.volume_usdt||0) - (a.data.volume_usdt||0) ||
          (b.data.volatility||0)  - (a.data.volatility||0)
        );

      d3.treemap()
        .tile(d3.treemapBinary)   // 깔끔한 줄 정렬
        .size([w, h])
        .paddingInner(3)
        .paddingOuter(3)
        .round(true)(root);

      const cell = svg.selectAll("g.cell")
        .data(root.leaves(), d => d.data.symbol)
        .enter().append("g")
        .attr("class", "cell")
        .attr("transform", d => `translate(${d.x0},${d.y0})`)
        .on("mousemove", (event, d) => {
          const { symbol, volatility, volume_usdt } = d.data;
          showTip(
            `<b>${symbol}</b><br/>변동성: <b>${fmtPct(volatility)}</b><br/>거래대금: <b>${formatCompact(volume_usdt)}</b> USDT`,
            event.clientX, event.clientY
          );
        })
        .on("mouseleave", hideTip)
        .on("click", (event, d) => {
          window.open(`https://www.binance.com/en/futures/${d.data.symbol}`, "_blank");
        });

      cell.append("rect")
        .attr("width",  d => Math.max(0, d.x1 - d.x0))
        .attr("height", d => Math.max(0, d.y1 - d.y0))
        .attr("fill",   d => {
          const base = d3.color(colorBase(d.data.color));
          const f = maxVol > 0 ? (0.55 + 0.40 * Math.min(1, (d.data.volatility||0) / maxVol)) : 0.75;
          base.r = Math.round(base.r * f);
          base.g = Math.round(base.g * f);
          base.b = Math.round(base.b * f);
          return base.formatHex();
        });

      const cx = d => (d.x0 + d.x1) / 2;
      const cy = d => (d.y0 + d.y1) / 2;
      const ww = d => (d.x1 - d.x0);
      const hh = d => (d.y1 - d.y0);

      const BIG_W = 260, BIG_H = 150;
      const MED_W = 140, MED_H = 90;

      cell.append("text")
        .attr("class", "label-center")
        .attr("x", d => cx(d))
        .attr("y", d => cy(d) - 8)
        .style("font-size", d => Math.min(Math.max(18, ww(d)*0.18), 46) + "px")
        .text(d => (ww(d) >= MED_W && hh(d) >= MED_H) ? d.data.symbol : "");

      cell.append("text")
        .attr("class", "pct-center")
        .attr("x", d => cx(d))
        .attr("y", d => cy(d) + 24)
        .style("font-size", d => Math.min(Math.max(12, ww(d)*0.12), 30) + "px")
        .text(d => {
          if (ww(d) >= BIG_W && hh(d) >= BIG_H) return (d.data.color==="green" ? "+" : "−") + d.data.volatility.toFixed(2) + "%";
          if (ww(d) >= MED_W && hh(d) >= MED_H) return (d.data.color==="green" ? "+" : "−") + d.data.volatility.toFixed(2) + "%";
          return "";
        });

      const small = cell.filter(d => ww(d) < MED_W || hh(d) < MED_H);
      small.append("text")
        .attr("class", "tiny")
        .attr("x", d => d.x0 + 6)
        .attr("y", d => d.y0 + 14)
        .text(d => d.data.symbol);

      small.append("text")
        .attr("class", "tiny")
        .attr("x", d => d.x0 + 6)
        .attr("y", d => d.y0 + 28)
        .text(d => (d.data.color==="green" ? "+" : "−") + d.data.volatility.toFixed(2) + "%");
    }
    /* ======================================================
       ▲▲▲ ② 추가/교체 끝
       ====================================================== */

    // ====== 데이터 가져오기 & 주기 갱신 ======
    async function fetchData(path) {
      const url = API_BASE + path;
      const res = await fetch(url, { cache: "no-store" });
      return await res.json();
    }

    async function refresh() {
      updateTimeLabel();
      secondsToNextUpdate = 60;

      const path = endpointSel.value;
      let raw;
      try {
        raw = await fetchData(path);
      } catch (_) {
        renderTreemap([]); return;
      }
      const data = normalizeData(raw, path);
      renderTreemap(data);
    }

    // 최초 실행 & 인터벌
    refresh();
    startCountdown();
    setInterval(refresh, 60 * 1000);

    // 엔드포인트 전환 즉시 갱신
    endpointSel.addEventListener("change", refresh);

    // 반응형은 유지 안 해도 되지만, 있어도 고정 사이즈로 렌더됨
    window.addEventListener("resize", () => refresh());
  </script>
</body>
</html>
