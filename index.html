<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>SUPERHERO Treemap — Volatility × Turnover (Auto 60s)</title>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@2.3.0/dist/chartjs-chart-treemap.min.js"></script>

  <style>
    :root { --scale: 0.70; --treemap-w: 1280px; --treemap-h: 720px; }
    html, body { margin:0; padding:0; background:#000; color:#fff; font-family:system-ui,-apple-system,Roboto,sans-serif; overflow:hidden; width:100vw; height:100vh; }
    body { transform:scale(var(--scale)); transform-origin:top left; width:calc(100%/var(--scale)); height:calc(100%/var(--scale)); padding:calc(28px/var(--scale)); }
    h1 { font-size:24px; margin:0 0 12px 0; }
    .row { display:flex; gap:16px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
    label, select { font-size:14px; color:#ddd; }
    select { background:#111; color:#fff; border:1px solid #333; border-radius:6px; padding:6px 10px; outline:none; }
    #time { font-size:14px; color:#aaa; }
    #countdown { margin-left:12px; color:#888; }
    #chartWrap { width:var(--treemap-w); height:var(--treemap-h); }
    #chart-area { width:var(--treemap-w); height:var(--treemap-h); display:block; border:1px solid #222; border-radius:10px; }
    .legend { font-size:12px; color:#bbb; display:flex; gap:16px; align-items:center; }
    .chip { width:14px; height:14px; border-radius:3px; display:inline-block; margin-right:6px; border:1px solid #333; }
    .chip.up { background:#afff00; } .chip.down { background:#f73f21; }
  </style>
</head>
<body>
  <h1>■ SUPERHERO 실시간 트리맵 (면적=변동성, 색상=등락, 진하기=거래대금) ■</h1>

  <div class="row">
    <div class="legend">
      <span><span class="chip up"></span>상승</span>
      <span><span class="chip down"></span>하락</span>
      <span>진하기 ↑ = 거래대금(USDT) ↑</span>
      <span>면적 ↑ = 변동성(%) ↑</span>
    </div>
  </div>

  <div class="row">
    <label for="endpoint">엔드포인트:</label>
    <select id="endpoint">
      <option value="/top_volatility_1m">1분 변동성</option>
      <option value="/top_volatility_5m" selected>5분 변동성</option>
      <option value="/top_volatility_15m">15분 변동성</option>
      <option value="/top_volatility_1h">1시간 변동성</option>
      <option value="/top_spike_1h_recent">신규코인 급등(1H)</option>
      <option value="/top_dump_1h_recent">신규코인 급락(1H)</option>
      <option value="/top_spike_1h_all">전종목 급등(1H)</option>
      <option value="/top_dump_1h_all">전종목 급락(1H)</option>
    </select>
    <span id="time">UTC 로딩 중...</span>
    <span id="countdown">다음 갱신까지 60s</span>
  </div>

  <div id="chartWrap">
    <canvas id="chart-area"></canvas>
  </div>

  <script>
    const API_BASE = "https://binance-flask-app-production.up.railway.app";
    const endpointSel = document.getElementById("endpoint");
    let secondsToNextUpdate = 60;

    function updateTimeLabel(){
      const n=new Date(); const y=n.getUTCFullYear();
      const m=String(n.getUTCMonth()+1).padStart(2,'0');
      const d=String(n.getUTCDate()).padStart(2,'0');
      const h=String(n.getUTCHours()).padStart(2,'0');
      const mm=String(n.getUTCMinutes()).padStart(2,'0');
      document.getElementById("time").textContent=`${y}-${m}-${d} ${h}:${mm} UTC`;
    }
    function startCountdown(){
      setInterval(()=>{ secondsToNextUpdate--; if(secondsToNextUpdate<=0) secondsToNextUpdate=60;
        document.getElementById("countdown").textContent=`다음 갱신까지 ${secondsToNextUpdate}s`; },1000);
    }

    const fmtPct = v => `${(Number(v)||0).toFixed(2)}%`;
    function formatCompact(num){
      const n=+num||0;
      if(n>=1e12) return (n/1e12).toFixed(2)+"T";
      if(n>=1e9)  return (n/1e9 ).toFixed(2)+"B";
      if(n>=1e6)  return (n/1e6 ).toFixed(2)+"M";
      if(n>=1e3)  return (n/1e3 ).toFixed(2)+"K";
      return n.toFixed(0);
    }
    const GREEN = "#2db84d";
    const RED   = "#c6453a";
    const colorFromSign = (sign) => (sign >= 0 ? GREEN : RED);

    // ── 데이터 정규화 (엔드포인트별 필드 편차 보정)
    function normalizeData(raw, endpointPath){
      const arr = Array.isArray(raw) ? raw : (Array.isArray(raw?.data) ? raw.data : []);
      const isSpike = endpointPath.includes("_spike_");
      const isDump  = endpointPath.includes("_dump_");

      return arr.map(d=>{
        // 변동성/등락률
        let vol = 0;
        if ("volatility" in d)        vol = Number(d.volatility) || 0;
        else if ("spike_pct" in d)    vol = Number(d.spike_pct)   || 0;
        else if ("dump_pct" in d)     vol = Number(d.dump_pct)    || 0;

        // 거래대금 (여러 키 중 존재값 사용)
        const turnover = [
          d.volume_usdt_1h, d.volume_usdt, d.volume, d.turnover
        ].map(v => Number(v))
         .find(v => Number.isFinite(v)) ?? 0;

        const sym = d.symbol || d.futures_symbol || d.name || "NA";

        // 색상 = 엔드포인트 우선 규칙 → 그 외는 부호로
        let sign = vol;
        if (isSpike) sign = Math.abs(vol);        // spike는 상승으로 간주
        if (isDump)  sign = -Math.abs(vol);       // dump는 하락으로 간주

        const color = sign >= 0 ? "green" : "red";
        return { symbol:sym, vol:vol, turnover:Math.max(0, turnover), color };
      }).filter(d=>d.symbol);
    }

    // ── 레이아웃 선택(면적=변동성)
    const TREEMAP_MAX_ITEMS=28, MIN_AREA_RATIO=0.01;
    function selectForLayout(data, w, h){
      const areaMetric = d => Math.abs(Number(d.vol)||0);  // 면적 기준 = |변동성|
      const totalAreaMetric = data.reduce((s,d)=>s+areaMetric(d),0);
      const area = w*h, minArea = area*MIN_AREA_RATIO;

      const sorted = data.slice().sort((a,b)=>areaMetric(b)-areaMetric(a));
      const picked = [];
      for(const d of sorted){
        if(picked.length>=TREEMAP_MAX_ITEMS) break;
        const est = totalAreaMetric>0 ? (areaMetric(d)/totalAreaMetric)*area : 0;
        if(est>=minArea) picked.push(d);
      }
      if(!picked.length && sorted.length) picked.push(sorted[0]);
      return {picked, totalAreaMetric};
    }

    let treemapChart=null;

    function renderTreemap(data){
      const w=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-w'));
      const h=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--treemap-h'));

      const {picked, totalAreaMetric} = selectForLayout(data, w, h);

      // ── 진하기: 거래대금 로그 정규화
      const logs = picked.map(d => Math.log1p(d.turnover||0));
      const logMin = Math.min(...logs, 0), logMax = Math.max(...logs, 1);
      const normT = v => {
        const t = Math.log1p(Math.max(0, Number(v)||0));
        return (t - logMin) / Math.max(1e-9, (logMax - logMin));
      };

      // tree
      const tree = picked.map(d=>{
        const vol = Number(d.vol)||0;
        const sign = (endpointSel.value.includes("_dump_")) ? -Math.abs(vol)
                   : (endpointSel.value.includes("_spike_")) ?  Math.abs(vol)
                   : vol;
        const plusMinus = sign >= 0 ? '+' : '−';
        const areaVal = Math.max(0.001, Math.abs(vol)); // 0 보호
        return {
          symbol: d.symbol,
          area: areaVal,                   // 면적 = |변동성|
          vol,                             // 툴팁용 원시 변동성
          turnover: d.turnover || 0,       // 진하기 기준
          colorSign: sign,                 // 색상 판단용
          displayValue: `${d.symbol} ${plusMinus}${Math.abs(vol).toFixed(2)}%`,
          _data: { w: w*(areaVal/Math.max(totalAreaMetric,1)), h }
        };
      });

      const ctx=document.getElementById("chart-area").getContext("2d");

      const backgroundColor = (c)=>{
        const r=c.raw||{};
        const base=colorFromSign(r.colorSign);
        const R=parseInt(base.slice(1,3),16), G=parseInt(base.slice(3,5),16), B=parseInt(base.slice(5,7),16);
        const f = 0.50 + 0.48 * normT(r.turnover); // 0.50~0.98
        return `rgba(${Math.round(R*f)},${Math.round(G*f)},${Math.round(B*f)},1)`;
      };

      const dataSet = {
        label:"SUPERHERO",
        tree,
        key:"area",
        groups:["displayValue"],
        spacing:2,
        borderWidth:1,
        borderColor:"rgba(10,10,10,0.9)",
        backgroundColor,
        labels:{
          display:true,
          formatter:(ctx)=>ctx.raw?.displayValue || "",
          color:'#eef2f6',
          align:'center',
          font:(ctx)=>{
            const r = ctx.raw || {};
            const base = Math.min(r._data?.w||80, r._data?.h||60);
            const size = Math.max(12, Math.min(48, base*0.16));
            return { size, weight:'800', lineHeight:1.15 };
          },
          padding:2,
          overflow:'hidden'
        }
      };

      const options={
        maintainAspectRatio:false,
        plugins:{
          legend:{ display:false },
          tooltip:{
            callbacks:{
              title:(items)=> (items[0].raw?.symbol)||'',
              label:(item)=>{
                const r=item.raw||{};
                const v = Number(r.vol)||0;
                const t = Number(r.turnover)||0;
                const sign = (endpointSel.value.includes("_dump_")) ? -Math.abs(v)
                           : (endpointSel.value.includes("_spike_")) ?  Math.abs(v)
                           : v;
                return [
                  `변동성(면적): ${fmtPct(sign)}`,
                  `거래대금(진하기): ${formatCompact(t)} USDT`
                ];
              }
            }
          }
        },
        layout:{ padding:3 }
      };

      if(treemapChart){ treemapChart.data.datasets[0]=dataSet; treemapChart.update(); }
      else{ treemapChart = new Chart(ctx, { type:'treemap', data:{ datasets:[dataSet] }, options }); }
    }

    async function fetchData(path){ const res=await fetch(API_BASE+path,{cache:"no-store"}); return await res.json(); }

    async function refresh(){
      updateTimeLabel(); secondsToNextUpdate=60;
      const path=endpointSel.value;
      let raw;
      try{ raw=await fetchData(path); } catch(_){ if(treemapChart){ treemapChart.destroy(); treemapChart=null; } return; }
      const data=normalizeData(raw,path);
      renderTreemap(data);
    }

    refresh(); startCountdown(); setInterval(refresh, 60*1000);
    endpointSel.addEventListener("change", refresh);
    window.addEventListener("resize", ()=>refresh());
  </script>
</body>
</html>
